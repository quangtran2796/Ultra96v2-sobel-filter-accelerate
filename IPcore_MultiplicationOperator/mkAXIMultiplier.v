//
// Generated by Bluespec Compiler (build 503820f)
//
// On Wed Dec 16 08:31:53 UTC 2020
//
//
// Ports:
// Name                         I/O  size props
// S00_AXI_arready                O     1
// S00_AXI_rvalid                 O     1
// S00_AXI_rdata                  O    64
// S00_AXI_rresp                  O     2
// S00_AXI_awready                O     1
// S00_AXI_wready                 O     1
// S00_AXI_bvalid                 O     1
// S00_AXI_bresp                  O     2
// aclk                           I     1 clock
// aresetn                        I     1 reset
// S00_AXI_arvalid                I     1
// S00_AXI_araddr                 I    32 reg
// S00_AXI_arprot                 I     3 reg
// S00_AXI_rready                 I     1
// S00_AXI_awvalid                I     1
// S00_AXI_awaddr                 I    32
// S00_AXI_awprot                 I     3
// S00_AXI_wvalid                 I     1
// S00_AXI_wdata                  I    64
// S00_AXI_wstrb                  I     8
// S00_AXI_bready                 I     1
//
// No combinational paths from inputs to outputs
//
//

`ifdef BSV_ASSIGNMENT_DELAY
`else
  `define BSV_ASSIGNMENT_DELAY
`endif

`ifdef BSV_POSITIVE_RESET
  `define BSV_RESET_VALUE 1'b1
  `define BSV_RESET_EDGE posedge
`else
  `define BSV_RESET_VALUE 1'b0
  `define BSV_RESET_EDGE negedge
`endif

module mkAXIMultiplier(aclk,
		       aresetn,

		       S00_AXI_arready,

		       S00_AXI_arvalid,

		       S00_AXI_araddr,

		       S00_AXI_arprot,

		       S00_AXI_rvalid,

		       S00_AXI_rready,

		       S00_AXI_rdata,

		       S00_AXI_rresp,

		       S00_AXI_awready,

		       S00_AXI_awvalid,

		       S00_AXI_awaddr,

		       S00_AXI_awprot,

		       S00_AXI_wready,

		       S00_AXI_wvalid,

		       S00_AXI_wdata,

		       S00_AXI_wstrb,

		       S00_AXI_bvalid,

		       S00_AXI_bready,

		       S00_AXI_bresp);
  input  aclk;
  input  aresetn;

  // value method slave_read_fab_arready
  output S00_AXI_arready;

  // action method slave_read_fab_parvalid
  input  S00_AXI_arvalid;

  // action method slave_read_fab_paraddr
  input  [31 : 0] S00_AXI_araddr;

  // action method slave_read_fab_parprot
  input  [2 : 0] S00_AXI_arprot;

  // value method slave_read_fab_rvalid
  output S00_AXI_rvalid;

  // action method slave_read_fab_prready
  input  S00_AXI_rready;

  // value method slave_read_fab_rdata
  output [63 : 0] S00_AXI_rdata;

  // value method slave_read_fab_rresp
  output [1 : 0] S00_AXI_rresp;

  // value method slave_write_fab_awready
  output S00_AXI_awready;

  // action method slave_write_fab_pawvalid
  input  S00_AXI_awvalid;

  // action method slave_write_fab_pawaddr
  input  [31 : 0] S00_AXI_awaddr;

  // action method slave_write_fab_pawprot
  input  [2 : 0] S00_AXI_awprot;

  // value method slave_write_fab_wready
  output S00_AXI_wready;

  // action method slave_write_fab_pwvalid
  input  S00_AXI_wvalid;

  // action method slave_write_fab_pwdata
  input  [63 : 0] S00_AXI_wdata;

  // action method slave_write_fab_pwstrb
  input  [7 : 0] S00_AXI_wstrb;

  // value method slave_write_fab_bvalid
  output S00_AXI_bvalid;

  // action method slave_write_fab_pbready
  input  S00_AXI_bready;

  // value method slave_write_fab_bresp
  output [1 : 0] S00_AXI_bresp;

  // signals for module outputs
  wire [63 : 0] S00_AXI_rdata;
  wire [1 : 0] S00_AXI_bresp, S00_AXI_rresp;
  wire S00_AXI_arready,
       S00_AXI_awready,
       S00_AXI_bvalid,
       S00_AXI_rvalid,
       S00_AXI_wready;

  // inlined wires
  wire [72 : 0] slave_write_dataIn_rv$port0__write_1,
		slave_write_dataIn_rv$port1__read,
		slave_write_dataIn_rv$port2__read;
  wire [35 : 0] slave_write_addrIn_rv$port0__write_1,
		slave_write_addrIn_rv$port1__read,
		slave_write_addrIn_rv$port2__read;
  wire slave_write_addrIn_rv$EN_port0__write,
       slave_write_addrIn_rv$EN_port1__write,
       slave_write_dataIn_rv$EN_port0__write,
       slave_write_dataIn_rv$EN_port1__write;

  // register addr_read_reg
  reg [31 : 0] addr_read_reg;
  wire [31 : 0] addr_read_reg$D_IN;
  wire addr_read_reg$EN;

  // register addr_write_reg
  reg [31 : 0] addr_write_reg;
  wire [31 : 0] addr_write_reg$D_IN;
  wire addr_write_reg$EN;

  // register operand_1
  reg [63 : 0] operand_1;
  wire [63 : 0] operand_1$D_IN;
  wire operand_1$EN;

  // register operand_2
  reg [63 : 0] operand_2;
  wire [63 : 0] operand_2$D_IN;
  wire operand_2$EN;

  // register product
  reg [63 : 0] product;
  wire [63 : 0] product$D_IN;
  wire product$EN;

  // register slave_read_isRst_isInReset
  reg slave_read_isRst_isInReset;
  wire slave_read_isRst_isInReset$D_IN, slave_read_isRst_isInReset$EN;

  // register slave_write_addrIn_rv
  reg [35 : 0] slave_write_addrIn_rv;
  wire [35 : 0] slave_write_addrIn_rv$D_IN;
  wire slave_write_addrIn_rv$EN;

  // register slave_write_dataIn_rv
  reg [72 : 0] slave_write_dataIn_rv;
  wire [72 : 0] slave_write_dataIn_rv$D_IN;
  wire slave_write_dataIn_rv$EN;

  // register slave_write_isRst_isInReset
  reg slave_write_isRst_isInReset;
  wire slave_write_isRst_isInReset$D_IN, slave_write_isRst_isInReset$EN;

  // ports of submodule slave_read_in
  wire [34 : 0] slave_read_in$D_IN, slave_read_in$D_OUT;
  wire slave_read_in$CLR,
       slave_read_in$DEQ,
       slave_read_in$EMPTY_N,
       slave_read_in$ENQ,
       slave_read_in$FULL_N;

  // ports of submodule slave_read_out
  wire [65 : 0] slave_read_out$D_IN, slave_read_out$D_OUT;
  wire slave_read_out$CLR,
       slave_read_out$DEQ,
       slave_read_out$EMPTY_N,
       slave_read_out$ENQ,
       slave_read_out$FULL_N;

  // ports of submodule slave_write_in
  wire [106 : 0] slave_write_in$D_IN, slave_write_in$D_OUT;
  wire slave_write_in$CLR,
       slave_write_in$DEQ,
       slave_write_in$EMPTY_N,
       slave_write_in$ENQ,
       slave_write_in$FULL_N;

  // ports of submodule slave_write_out
  wire [1 : 0] slave_write_out$D_IN, slave_write_out$D_OUT;
  wire slave_write_out$CLR,
       slave_write_out$DEQ,
       slave_write_out$EMPTY_N,
       slave_write_out$ENQ,
       slave_write_out$FULL_N;

  // rule scheduling signals
  wire WILL_FIRE_RL_handleWriteRequest;

  // remaining internal signals
  reg [63 : 0] CASE_addr_read_reg_0_operand_1_1_operand_2_pro_ETC__q1;
  wire [127 : 0] operand_1_2_MUL_operand_2_3___d86;

  // value method slave_read_fab_arready
  assign S00_AXI_arready =
	     !slave_read_isRst_isInReset && slave_read_in$FULL_N ;

  // value method slave_read_fab_rvalid
  assign S00_AXI_rvalid =
	     !slave_read_isRst_isInReset && slave_read_out$EMPTY_N ;

  // value method slave_read_fab_rdata
  assign S00_AXI_rdata =
	     slave_read_out$EMPTY_N ? slave_read_out$D_OUT[65:2] : 64'd0 ;

  // value method slave_read_fab_rresp
  assign S00_AXI_rresp =
	     slave_read_out$EMPTY_N ? slave_read_out$D_OUT[1:0] : 2'd0 ;

  // value method slave_write_fab_awready
  assign S00_AXI_awready =
	     !slave_write_isRst_isInReset && !slave_write_addrIn_rv[35] ;

  // value method slave_write_fab_wready
  assign S00_AXI_wready =
	     !slave_write_isRst_isInReset && !slave_write_dataIn_rv[72] ;

  // value method slave_write_fab_bvalid
  assign S00_AXI_bvalid =
	     !slave_write_isRst_isInReset && slave_write_out$EMPTY_N ;

  // value method slave_write_fab_bresp
  assign S00_AXI_bresp =
	     slave_write_out$EMPTY_N ? slave_write_out$D_OUT : 2'd0 ;

  // submodule slave_read_in
  FIFO2 #(.width(32'd35), .guarded(32'd1)) slave_read_in(.RST(aresetn),
							 .CLK(aclk),
							 .D_IN(slave_read_in$D_IN),
							 .ENQ(slave_read_in$ENQ),
							 .DEQ(slave_read_in$DEQ),
							 .CLR(slave_read_in$CLR),
							 .D_OUT(slave_read_in$D_OUT),
							 .FULL_N(slave_read_in$FULL_N),
							 .EMPTY_N(slave_read_in$EMPTY_N));

  // submodule slave_read_out
  FIFO2 #(.width(32'd66), .guarded(32'd1)) slave_read_out(.RST(aresetn),
							  .CLK(aclk),
							  .D_IN(slave_read_out$D_IN),
							  .ENQ(slave_read_out$ENQ),
							  .DEQ(slave_read_out$DEQ),
							  .CLR(slave_read_out$CLR),
							  .D_OUT(slave_read_out$D_OUT),
							  .FULL_N(slave_read_out$FULL_N),
							  .EMPTY_N(slave_read_out$EMPTY_N));

  // submodule slave_write_in
  FIFO2 #(.width(32'd107), .guarded(32'd1)) slave_write_in(.RST(aresetn),
							   .CLK(aclk),
							   .D_IN(slave_write_in$D_IN),
							   .ENQ(slave_write_in$ENQ),
							   .DEQ(slave_write_in$DEQ),
							   .CLR(slave_write_in$CLR),
							   .D_OUT(slave_write_in$D_OUT),
							   .FULL_N(slave_write_in$FULL_N),
							   .EMPTY_N(slave_write_in$EMPTY_N));

  // submodule slave_write_out
  FIFO2 #(.width(32'd2), .guarded(32'd1)) slave_write_out(.RST(aresetn),
							  .CLK(aclk),
							  .D_IN(slave_write_out$D_IN),
							  .ENQ(slave_write_out$ENQ),
							  .DEQ(slave_write_out$DEQ),
							  .CLR(slave_write_out$CLR),
							  .D_OUT(slave_write_out$D_OUT),
							  .FULL_N(slave_write_out$FULL_N),
							  .EMPTY_N(slave_write_out$EMPTY_N));

  // rule RL_handleWriteRequest
  assign WILL_FIRE_RL_handleWriteRequest =
	     slave_write_in$EMPTY_N && slave_write_out$FULL_N ;

  // inlined wires
  assign slave_write_addrIn_rv$EN_port0__write =
	     !slave_write_addrIn_rv[35] && !slave_write_isRst_isInReset &&
	     S00_AXI_awvalid ;
  assign slave_write_addrIn_rv$port0__write_1 =
	     { 1'd1, S00_AXI_awaddr, S00_AXI_awprot } ;
  assign slave_write_addrIn_rv$port1__read =
	     slave_write_addrIn_rv$EN_port0__write ?
	       slave_write_addrIn_rv$port0__write_1 :
	       slave_write_addrIn_rv ;
  assign slave_write_addrIn_rv$EN_port1__write =
	     slave_write_addrIn_rv$port1__read[35] &&
	     slave_write_dataIn_rv$port1__read[72] &&
	     slave_write_in$FULL_N ;
  assign slave_write_addrIn_rv$port2__read =
	     slave_write_addrIn_rv$EN_port1__write ?
	       36'h2AAAAAAAA :
	       slave_write_addrIn_rv$port1__read ;
  assign slave_write_dataIn_rv$EN_port0__write =
	     !slave_write_dataIn_rv[72] && !slave_write_isRst_isInReset &&
	     S00_AXI_wvalid ;
  assign slave_write_dataIn_rv$port0__write_1 =
	     { 1'd1, S00_AXI_wdata, S00_AXI_wstrb } ;
  assign slave_write_dataIn_rv$port1__read =
	     slave_write_dataIn_rv$EN_port0__write ?
	       slave_write_dataIn_rv$port0__write_1 :
	       slave_write_dataIn_rv ;
  assign slave_write_dataIn_rv$EN_port1__write =
	     slave_write_addrIn_rv$port1__read[35] &&
	     slave_write_dataIn_rv$port1__read[72] &&
	     slave_write_in$FULL_N ;
  assign slave_write_dataIn_rv$port2__read =
	     slave_write_dataIn_rv$EN_port1__write ?
	       73'h0AAAAAAAAAAAAAAAAAA :
	       slave_write_dataIn_rv$port1__read ;

  // register addr_read_reg
  assign addr_read_reg$D_IN = slave_read_in$D_OUT[34:3] ;
  assign addr_read_reg$EN = slave_read_in$EMPTY_N && slave_read_out$FULL_N ;

  // register addr_write_reg
  assign addr_write_reg$D_IN = 32'h0 ;
  assign addr_write_reg$EN = 1'b0 ;

  // register operand_1
  assign operand_1$D_IN = slave_write_in$D_OUT[74:11] ;
  assign operand_1$EN =
	     WILL_FIRE_RL_handleWriteRequest &&
	     slave_write_in$D_OUT[106:75] == 32'd0 ;

  // register operand_2
  assign operand_2$D_IN = slave_write_in$D_OUT[74:11] ;
  assign operand_2$EN =
	     WILL_FIRE_RL_handleWriteRequest &&
	     slave_write_in$D_OUT[106:75] == 32'd1 ;

  // register product
  assign product$D_IN = operand_1_2_MUL_operand_2_3___d86[63:0] ;
  assign product$EN = 1'd1 ;

  // register slave_read_isRst_isInReset
  assign slave_read_isRst_isInReset$D_IN = 1'd0 ;
  assign slave_read_isRst_isInReset$EN = slave_read_isRst_isInReset ;

  // register slave_write_addrIn_rv
  assign slave_write_addrIn_rv$D_IN = slave_write_addrIn_rv$port2__read ;
  assign slave_write_addrIn_rv$EN = 1'b1 ;

  // register slave_write_dataIn_rv
  assign slave_write_dataIn_rv$D_IN = slave_write_dataIn_rv$port2__read ;
  assign slave_write_dataIn_rv$EN = 1'b1 ;

  // register slave_write_isRst_isInReset
  assign slave_write_isRst_isInReset$D_IN = 1'd0 ;
  assign slave_write_isRst_isInReset$EN = slave_write_isRst_isInReset ;

  // submodule slave_read_in
  assign slave_read_in$D_IN = { S00_AXI_araddr, S00_AXI_arprot } ;
  assign slave_read_in$ENQ =
	     slave_read_in$FULL_N && !slave_read_isRst_isInReset &&
	     S00_AXI_arvalid ;
  assign slave_read_in$DEQ = slave_read_in$EMPTY_N && slave_read_out$FULL_N ;
  assign slave_read_in$CLR = 1'b0 ;

  // submodule slave_read_out
  assign slave_read_out$D_IN =
	     { CASE_addr_read_reg_0_operand_1_1_operand_2_pro_ETC__q1,
	       2'd0 } ;
  assign slave_read_out$ENQ =
	     slave_read_in$EMPTY_N && slave_read_out$FULL_N &&
	     (addr_read_reg == 32'd0 || addr_read_reg == 32'd1 ||
	      addr_read_reg == 32'd2) ;
  assign slave_read_out$DEQ =
	     slave_read_out$EMPTY_N && !slave_read_isRst_isInReset &&
	     S00_AXI_rready ;
  assign slave_read_out$CLR = 1'b0 ;

  // submodule slave_write_in
  assign slave_write_in$D_IN =
	     { slave_write_addrIn_rv$port1__read[34:3],
	       slave_write_dataIn_rv$port1__read[71:0],
	       slave_write_addrIn_rv$port1__read[2:0] } ;
  assign slave_write_in$ENQ =
	     slave_write_addrIn_rv$port1__read[35] &&
	     slave_write_dataIn_rv$port1__read[72] &&
	     slave_write_in$FULL_N ;
  assign slave_write_in$DEQ = WILL_FIRE_RL_handleWriteRequest ;
  assign slave_write_in$CLR = 1'b0 ;

  // submodule slave_write_out
  assign slave_write_out$D_IN = 2'd0 ;
  assign slave_write_out$ENQ = WILL_FIRE_RL_handleWriteRequest ;
  assign slave_write_out$DEQ =
	     slave_write_out$EMPTY_N && !slave_write_isRst_isInReset &&
	     S00_AXI_bready ;
  assign slave_write_out$CLR = 1'b0 ;

  // remaining internal signals
  assign operand_1_2_MUL_operand_2_3___d86 = operand_1 * operand_2 ;
  always@(addr_read_reg or product or operand_1 or operand_2)
  begin
    case (addr_read_reg)
      32'd0:
	  CASE_addr_read_reg_0_operand_1_1_operand_2_pro_ETC__q1 = operand_1;
      32'd1:
	  CASE_addr_read_reg_0_operand_1_1_operand_2_pro_ETC__q1 = operand_2;
      default: CASE_addr_read_reg_0_operand_1_1_operand_2_pro_ETC__q1 =
		   product;
    endcase
  end

  // handling of inlined registers

  always@(posedge aclk)
  begin
    if (aresetn == `BSV_RESET_VALUE)
      begin
        addr_read_reg <= `BSV_ASSIGNMENT_DELAY 32'd0;
	addr_write_reg <= `BSV_ASSIGNMENT_DELAY 32'd0;
	operand_1 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	operand_2 <= `BSV_ASSIGNMENT_DELAY 64'd0;
	product <= `BSV_ASSIGNMENT_DELAY 64'd0;
	slave_write_addrIn_rv <= `BSV_ASSIGNMENT_DELAY 36'h2AAAAAAAA;
	slave_write_dataIn_rv <= `BSV_ASSIGNMENT_DELAY
	    73'h0AAAAAAAAAAAAAAAAAA;
      end
    else
      begin
        if (addr_read_reg$EN)
	  addr_read_reg <= `BSV_ASSIGNMENT_DELAY addr_read_reg$D_IN;
	if (addr_write_reg$EN)
	  addr_write_reg <= `BSV_ASSIGNMENT_DELAY addr_write_reg$D_IN;
	if (operand_1$EN) operand_1 <= `BSV_ASSIGNMENT_DELAY operand_1$D_IN;
	if (operand_2$EN) operand_2 <= `BSV_ASSIGNMENT_DELAY operand_2$D_IN;
	if (product$EN) product <= `BSV_ASSIGNMENT_DELAY product$D_IN;
	if (slave_write_addrIn_rv$EN)
	  slave_write_addrIn_rv <= `BSV_ASSIGNMENT_DELAY
	      slave_write_addrIn_rv$D_IN;
	if (slave_write_dataIn_rv$EN)
	  slave_write_dataIn_rv <= `BSV_ASSIGNMENT_DELAY
	      slave_write_dataIn_rv$D_IN;
      end
  end

  always@(posedge aclk or `BSV_RESET_EDGE aresetn)
  if (aresetn == `BSV_RESET_VALUE)
    begin
      slave_read_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY 1'd1;
      slave_write_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY 1'd1;
    end
  else
    begin
      if (slave_read_isRst_isInReset$EN)
	slave_read_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY
	    slave_read_isRst_isInReset$D_IN;
      if (slave_write_isRst_isInReset$EN)
	slave_write_isRst_isInReset <= `BSV_ASSIGNMENT_DELAY
	    slave_write_isRst_isInReset$D_IN;
    end

  // synopsys translate_off
  `ifdef BSV_NO_INITIAL_BLOCKS
  `else // not BSV_NO_INITIAL_BLOCKS
  initial
  begin
    addr_read_reg = 32'hAAAAAAAA;
    addr_write_reg = 32'hAAAAAAAA;
    operand_1 = 64'hAAAAAAAAAAAAAAAA;
    operand_2 = 64'hAAAAAAAAAAAAAAAA;
    product = 64'hAAAAAAAAAAAAAAAA;
    slave_read_isRst_isInReset = 1'h0;
    slave_write_addrIn_rv = 36'hAAAAAAAAA;
    slave_write_dataIn_rv = 73'h0AAAAAAAAAAAAAAAAAA;
    slave_write_isRst_isInReset = 1'h0;
  end
  `endif // BSV_NO_INITIAL_BLOCKS
  // synopsys translate_on
endmodule  // mkAXIMultiplier

